
## Общее описание

В этой задаче вам надо разработать класс для представления рациональных чисел и внедрить его в систему типов языка С++ так, чтобы им можно было пользоваться естественным образом. Задание состоит из нескольких частей. К каждой части приложен файл с заготовкой программы, который имеет следующую структуру

    #include <iostream>
    
    using namespace std;
    
    // Комментарии, которые говорят, что именно нужно реализовать в этой программе
    
    int main() {
    
        // Набор юнит-тестов для вашей реализации
    
        cout << "OK" << endl;
    
        return 0;
    
    }

Вам нужно,  **не меняя тело функции main,**  реализовать то, что предложено в комментариях, так, чтобы ваша программа выводила на экран сообщение OK. Функция main содержит ряд юнит-тестов, которые проверяют правильность вашей реализации. Если эти тесты находят ошибку в вашей реализации, то вместо OK программа выведет подсказку о том, что именно работает неправильно.

Когда ваша программа начнёт выводить OK, можете отправлять свой файл на проверку. Ваша реализация будет тестироваться на другом, более полном наборе тестов.  **То есть, если ваша программа выводит OK, то это не даёт гарантии, что ваша реализация будет принята тестирующей системой.**  В случае неудачной посылки тестирующая система также выдаст вам подсказку о том, какая именно часть реализации работает неправильно.

Внимательно изучите набор юнит-тестов для  **каждой**  заготовки решения. Тесты описывают требования, предъявляемые к вашей реализации, которые могут быть не указаны в условии задач

На проверку можно отправлять весь файл с вашей реализацией: функцию main удалять из него не нужно.

## Часть 1

В первой части Вам надо реализовать класс Rational, который представляет собой рациональное число вида p/q, где p — целое, а q — натуральное и диапазоны возможных значений p, q таковы, что могут быть представлены типом int. При этом, класс Rational должен иметь следующий интерфейс:

    class Rational {
    
    public:
    
      Rational();
    
      Rational(int numerator, int denominator);
    
      int Numerator() const;
    
      int Denominator() const;
    
    };

Класс Rational должен гарантировать, что p/q — это несократимая дробь. Например, код

    Rational r(4, 6);
    cout << r.Numerator() << '/' << r.Denominator();

должен выводить «2/3» — именно поэтому мы делаем Rational классом, а не структурой. Структура позволила бы нарушить этот инвариант:

    struct Rational {
        int numerator, denominator;    
    };
    
    Rational r{2, 3};
    r.numerator = 6; // Нарушен инвариант несократимости

Список требований, предъявляемых к реализации интерфейса класса Rational:

1.  Конструктор по умолчанию должен создавать дробь с числителем 0 и знаменателем 1.
2.  При конструировании объека класса Rational с параметрами p и q должно выполняться сокращение дроби p/q (здесь вам может пригодиться решение задачи «Наибольший общий делитель»).
3.  Если дробь p/q отрицательная, то объект Rational(p, q) должен иметь отрицательный числитель и положительный знаменатель.
4.  Если дробь p/q положительная, то объект Rational(p, q) должен иметь положительные числитель и знаменатель (обратите внимание на случай Rational(-2, -3)).
5.  Если числитель дроби равен нулю, то знаменатель должен быть равен 1.

**Гарантируется, что ни в одном из тестов, на которых будет тестироваться ваша реализация, не будет знаменателя, равного нулю.**

### Замечание:

В стандарте языка C++17 для вычисления НОД имеется стандартная функция gcd. Допустимо использовать данную функцию для сокращения дробей. Подробнее с данной функцией и её ограничениями можно ознакомиться по ссылке:  [https://en.cppreference.com/w/cpp/numeric/gcd](https://en.cppreference.com/w/cpp/numeric/gcd "https://en.cppreference.com/w/cpp/numeric/gcd")

### Шаблон программы:

[rational_interface.cpp](https://d3c33hcgiwev3.cloudfront.net/_3eeecdad5734b31db47bc7272453f0ab_rational_interface.cpp?Expires=1596153600&Signature=PlrR53ScV6x42sxKSRBLyn0WX5tzQXZGKjs-5n8ZWs9vwaSVKexm-W7V6feUQSioamj2VF4mcAmULEQS2kUO6PKErTFVJYIiYetajyKxy89d7D4VqngwWAmUllR-w484HvTqD14otnEivyQ5axE3E8G3ufus1D8s~LLzus6SJRA_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Часть 2

Реализуйте для класса Rational операторы ==, + и - так, чтобы операции с дробями можно было записывать естественным образом. Например, следующий код должен быть валидным:

    const Rational r = Rational(1, 2) + Rational(1, 3) - Rational(1, 4);
    
    if (r == Rational(7, 12)) {
    
      cout << "equal";
    
    }

**Гарантируется, что во всех тестах, на которых будет тестироваться ваша реализация, числители и знаменатели ВСЕХ дробей (как исходных, так и получившихся в результате соответствующих арифметических операций) будут укладываться в диапазон типа int.**

### Шаблон программы:

[rational_eq_add_sub.cpp](https://d3c33hcgiwev3.cloudfront.net/_ce23ea19242276b22976595011c64042_rational_eq_add_sub.cpp?Expires=1596153600&Signature=U8Hy0lE~PmHdlqzSOgtl5ixZexiXvyLnNFgrF1mFIbHkXbmpX~l~SyFYk0bY1Y8YlHP~I1gl9~19Txv05A6UsSAqadD7q6BOqSVwiMQ4293Q8JfRwR~UGjCYGi7zwPmc6TkZd6rYVOsOVYYsymxFxphivzxyKxtEACnEo3n9X5Q_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Часть 3

Аналогично предыдущей части, реализуйте операторы * и /. Например, следующий код должен быть валидным:

    const Rational r = Rational(1, 2) * Rational(1, 3) / Rational(1, 4);
    
    if (r == Rational(2, 3)) {
	    cout << "equal";
    }

**Как и в предыдущем случае, гарантируется, что во всех тестах, на которых будет тестироваться ваша реализация, числители и знаменатели ВСЕХ дробей (как исходных, так и получившихся в результате соответствующих арифметических операций) будут укладываться в диапазон типа int.**

**Кроме того, гарантируется, что ни в одном из тестов, на которых будет тестироваться ваша реализация, не будет выполняться деление на ноль.**

### Шаблон программы:

[rational_mult_div.cpp](https://d3c33hcgiwev3.cloudfront.net/_13549043214800e40c8444137d82a63b_rational_mult_div.cpp?Expires=1596153600&Signature=jpHvM7yl0FFRHYmE0uocoZwbFEcjCXg41DHc6sCLsGpbSYG2iET~XDByHOM4LVY~ipxHudLAogYGaMS0DUiJ8K9v662m8eOk~U5ePZcj8yyP0ujcAUlLDECVMjvLWST~3JJXI7muHZYly5Wj9GsMXAgsgnbmorvGfJI4P6KqVq4_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Часть 4

В этой части вам нужно реализовать операторы ввода и вывода для класса Rational. В результате у вас должен работать, например, такой код

    Rational r;
    cin >> r;
    cout << r;

### Шаблон программы:

[rational_io.cpp](https://d3c33hcgiwev3.cloudfront.net/_e1ae6abc912ed8054b3bc9cf8f208258_rational_io.cpp?Expires=1596153600&Signature=EhjNohbNDXO5z7uxfIflH8xCQy3drJS0Unr6e73ovj8WDzQ-Ykc5rXgLwauWPqisoSbTb479Fikkfr3JgbPCi364iOv~fz-Wtplcq0u0MJOHPOxFNCUrTpbUjbAUcE8l7Rxq5F-tMptvmJIVs4XFb6PmbgJYmUPBqSNHn3q-w9w_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Часть 5

Наконец, вам нужно реализовать возможность использовать объекты класса Rational в качестве элементов контейнера set и ключей в контейнере map. Пример:

    set<Rational> rationals;
    rationals.insert(Rational(1, 2));
    rationals.insert(Rational(1, 3));
    map<Rational, string> name;
    name[Rational(1, 2)] = "одна вторая";

### Шаблон программы:

[rational_map.cpp](https://d3c33hcgiwev3.cloudfront.net/_9d5919cda1901a8bc1955a69a74865b1_rational_map.cpp?Expires=1596153600&Signature=Ou8cn1vVKF9jRljkUtOP3nMjFzBv~0WEMqW~n9oqGOGzYaoeqbaL6RRkT2ZZJYdqv2tlW6v2378eewui-LXO1XV6VgjC4k9sROkvsbZnUPKHvjj~ws8pktuwcH15zyD5Nn4jEPMVbPZNWLxZ23c2lgI2kitcCQg4B6IPYIRgUHs_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)



Вспомним класс Rational, который мы реализовали в задачах, посвящённых перегрузке операторов. Там специально говорилось, что в тестах объекты класса Rational никогда не создаются с нулевым знаменателем и никогда не выполняется деление на ноль. Настало время избавиться от этого ограничения и научиться обрабатывать нулевой знаменатель и деление на ноль. В этой задаче вам предстоит это сделать.

Поменяйте реализацию конструктора класса Rational так, чтобы он выбрасывал исключение  [invalid_argument](https://en.cppreference.com/w/cpp/error/invalid_argument), если знаменатель равен нулю. Кроме того, переделайте реализацию оператора деления для класса Rational так, чтобы он выбрасывал исключение  [domain_error](https://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&search=domain_error), если делитель равен нулю.

Напомним, что вам надо реализовать интерфейс

    class Rational {
    public:
      Rational();
      Rational(int numerator, int denominator);
      int Numerator() const;
      int Denominator() const;
    };
и оператор деления для класса Rational

    Rational operator / (const Rational& lhs, const Rational& rhs);

Так же, как и в задачах на перегрузку операторов, вам будет предложен файл с заготовкой кода. Функция main в этом файле содержит ряд юнит-тестов, которые позволят вам проверить свою реализацию. При проверке вашего решения оно будет тестироваться на более полном наборе тестов, так что успешное прохождение всех юнит-тестов не гарантирует, что ваша реализация будет зачтена.

Шаблон программы:

[rational_throw.cpp](https://d3c33hcgiwev3.cloudfront.net/_5e163726188df62884bc6a5e9777eb33_rational_throw.cpp?Expires=1596240000&Signature=PEgQbScgvNBDinywz2rYJdY~2srg3I1vffFD0QUdlSai~eUZEWLVIa7dwotodbh9MKttntjl6x4iZXo34hwaQwat6x5NKOqrYxeEz5ZIUj~RRfC4ePw3js8AVgBLWjiixlBXF6VbLZUjEOQCO1hbq1sI~4yUt7zdkoSMpVqxbOY_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)



Итак, теперь у нас с вами есть полноценный тип для представления обыкновенных дробей: класс Rational интегрирован в язык с помощью перегрузки операторов и не позволяет выполнять некорректные операции за счёт выбрасывания исключений. Давайте на основе класса Rational создадим простой калькулятор для обыкновенных дробей.

Вам надо написать программу, которая считывает из стандартного ввода одну строку в формате  _**ДРОБЬ_1 операция ДРОБЬ_2**_.  _ДРОБЬ_1_  и  _ДРОБЬ_2_  имеют формат X/Y, где X — целое, а Y — целое неотрицательное число.  _операция_  — это один из символов '+', '-', '*', '/'.

Если  _ДРОБЬ_1_  или _ДРОБЬ_2_  является некорректной обыкновенной дробью, ваша программа должна вывести в стандартный вывод сообщение "Invalid argument". Если считанная операция — это деление на ноль, выведите в стандартный вывод сообщение "Division by zero". В противном случае выведите результат операции.

### Пример

**stdin**

**stdout**

    1/2 + 1/3
    
    5/6
    
    1/2 + 5/0
    
    Invalid argument
    
    4/5 / 0/8
    
    Division by zero
